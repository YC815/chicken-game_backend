<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chicken Game - æ¸¬è©¦æ§å° v2.0</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            background: #0a0a0a;
            color: #00ff00;
            padding: 20px;
        }

        .container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            max-width: 2200px;
            margin: 0 auto;
        }

        .panel {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 20px;
            overflow-y: auto;
            max-height: calc(100vh - 180px);
        }

        .panel h2 {
            color: #00ffff;
            border-bottom: 2px solid #333;
            padding-bottom: 10px;
            margin-bottom: 20px;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .section {
            margin-bottom: 30px;
        }

        .section h3 {
            color: #ffff00;
            margin-bottom: 15px;
            font-size: 14px;
            text-transform: uppercase;
        }

        button {
            background: #2a2a2a;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 10px 20px;
            margin: 5px 5px 5px 0;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
            border-radius: 3px;
            transition: all 0.2s;
        }

        button:hover:not(:disabled) {
            background: #00ff00;
            color: #000;
        }

        button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            border-color: #555;
            color: #555;
        }

        button.publish-btn {
            border-color: #ff9900;
            color: #ff9900;
        }

        button.publish-btn:hover:not(:disabled) {
            background: #ff9900;
            color: #000;
        }

        button.skip-btn {
            border-color: #ff0000;
            color: #ff0000;
        }

        button.skip-btn:hover:not(:disabled) {
            background: #ff0000;
            color: #fff;
        }

        input {
            background: #0a0a0a;
            color: #00ff00;
            border: 1px solid #333;
            padding: 8px;
            font-family: inherit;
            font-size: 12px;
            border-radius: 3px;
            width: 100%;
            margin-bottom: 10px;
        }

        input:focus {
            outline: none;
            border-color: #00ff00;
        }

        .info {
            background: #0f0f0f;
            padding: 10px;
            margin: 10px 0;
            border-left: 3px solid #00ffff;
            font-size: 12px;
        }

        .info-label {
            color: #888;
            display: inline-block;
            width: 120px;
        }

        .info-value {
            color: #00ff00;
            font-weight: bold;
        }

        .progress-bar {
            background: #0a0a0a;
            height: 20px;
            border: 1px solid #333;
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            background: linear-gradient(90deg, #00ff00 0%, #00ffff 100%);
            height: 100%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            color: #000;
        }

        .log {
            background: #0a0a0a;
            padding: 15px;
            margin: 10px 0;
            border: 1px solid #222;
            border-radius: 3px;
            max-height: 300px;
            overflow-y: auto;
            font-size: 11px;
        }

        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-left: 2px solid #333;
            padding-left: 10px;
        }

        .log-entry.ws-event {
            border-left-color: #ff00ff;
            color: #ff00ff;
        }

        .log-entry.api-call {
            border-left-color: #00ffff;
            color: #00ffff;
        }

        .log-entry.error {
            border-left-color: #ff0000;
            color: #ff0000;
        }

        .log-entry.success {
            border-left-color: #00ff00;
            color: #00ff00;
        }

        .status-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            margin-left: 10px;
        }

        .status-waiting { background: #555; color: #fff; }
        .status-playing { background: #00ff00; color: #000; }
        .status-finished { background: #ff0000; color: #fff; }
        .status-ready { background: #ff9900; color: #000; }

        .choice-btn {
            display: block;
            width: 100%;
            margin: 5px 0;
        }

        .result-box {
            background: #1a1a1a;
            border: 1px solid #333;
            padding: 10px;
            margin: 10px 0;
            border-radius: 3px;
        }

        .result-box h4 {
            color: #ffff00;
            margin-bottom: 10px;
            font-size: 13px;
        }

        .payoff-positive { color: #00ff00; }
        .payoff-negative { color: #ff0000; }

        .ws-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: bold;
        }

        .ws-connected {
            background: #00ff00;
            color: #000;
        }

        .ws-disconnected {
            background: #ff0000;
            color: #fff;
        }

        .message-box {
            background: #2a2a2a;
            padding: 10px;
            margin: 10px 0;
            border-radius: 3px;
            border: 1px solid #555;
        }

        textarea {
            background: #0a0a0a;
            color: #00ff00;
            border: 1px solid #333;
            padding: 8px;
            font-family: inherit;
            font-size: 12px;
            border-radius: 3px;
            width: 100%;
            margin: 10px 0;
            resize: vertical;
        }

        textarea:focus {
            outline: none;
            border-color: #00ff00;
        }

        .indicator-symbol {
            font-size: 24px;
            display: inline-block;
            margin-left: 10px;
        }

        .waiting-indicator {
            color: #ff9900;
            font-size: 14px;
            padding: 10px;
            background: #1a1a1a;
            border: 1px solid #ff9900;
            border-radius: 3px;
            margin: 10px 0;
            text-align: center;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* å¿«é€Ÿæ¸¬è©¦æµç¨‹é¢æ¿ */
        .flow-box {
            background: #111;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 12px;
        }

        .flow-row {
            display: grid;
            grid-template-columns: 28px 1fr auto auto;
            align-items: center;
            gap: 8px;
            margin: 6px 0;
        }

        .flow-step {
            color: #00ffff;
            font-weight: bold;
        }

        .badge {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
        }

        .badge-pending { background: #333; color: #ccc; }
        .badge-running { background: #ff9900; color: #000; }
        .badge-done { background: #00ff00; color: #000; }
        .badge-error { background: #ff0000; color: #fff; }
    </style>
</head>
<body>
    <div class="ws-status" id="wsStatus">POLL: STOPPED</div>

    <div class="container">
        <!-- HOST PANEL -->
        <div class="panel">
            <h2>ğŸ® ä¸»æŒäººæ§å° v2.0</h2>

            <div class="section">
                <h3>1. å»ºç«‹æˆ¿é–“ï¼ˆç”¢ç”Ÿæˆ¿è™Ÿ + ä¸»æŒäºº IDï¼‰</h3>
                <div class="info" style="margin-bottom: 8px;">æŒ‰ä¸‹å¾Œæœƒå•Ÿå‹•çŸ­è¼ªè©¢ï¼Œä¸¦æŠŠæˆ¿è™Ÿå¡«åˆ°å…©ä½ç©å®¶æ¬„ä½ã€‚</div>
                <button onclick="createRoom()">å»ºç«‹æˆ¿é–“</button>
                <div class="info" id="hostInfo" style="display: none;">
                    <div><span class="info-label">Room ID:</span><span class="info-value" id="hostRoomId">-</span></div>
                    <div><span class="info-label">æˆ¿è™Ÿ Code:</span><span class="info-value" id="hostCode">-</span></div>
                    <div><span class="info-label">ä¸»æŒäºº Player ID:</span><span class="info-value" id="hostPlayerId">-</span></div>
                </div>
            </div>

            <div class="section">
                <h3>2. éŠæˆ²æµç¨‹æ§åˆ¶</h3>
                <div class="info" style="margin-bottom: 8px;">é †åºï¼šå…ˆ Start â†’ æ¯å›åˆæŒ‰ Next Round â†’ çµæŸæ™‚ Endã€‚</div>
                <button onclick="startGame()" id="btnStartGame" disabled>é–‹å§‹éŠæˆ²</button>
                <button onclick="nextRound()" id="btnNextRound" disabled>ä¸‹ä¸€å›åˆ</button>
                <button onclick="endGame()" id="btnEndGame" disabled>çµæŸéŠæˆ²</button>
            </div>

            <div class="section">
                <h3>3. å›åˆå…¬å¸ƒ/è·³é</h3>
                <div class="info" style="margin-bottom: 8px;">æ‰€æœ‰ç©å®¶å‡ºå®Œç‰Œå¾Œæœƒäº®èµ·ã€Œå…¬å¸ƒçµæœã€ï¼Œè‹¥å¡ä½å¯ç”¨ã€Œè·³éã€ç›´æ¥çµç®—ã€‚</div>
                <button class="publish-btn" onclick="publishRoundResults()" id="btnPublishRound" disabled>ğŸ“¢ å…¬å¸ƒçµæœ</button>
                <button class="skip-btn" onclick="skipRound()" id="btnSkipRound" disabled>â­ï¸ è·³éæœ¬å›åˆ</button>
                <div class="info" id="roundControlInfo" style="display: none; border-left-color: #ff9900;">
                    <div><span class="info-label">ç›®å‰å›åˆ:</span><span class="info-value" id="roundControlNumber">-</span></div>
                    <div><span class="info-label">å›åˆç‹€æ…‹:</span><span class="info-value" id="roundControlStatus">-</span></div>
                    <div style="margin-top: 10px;">
                        <div class="info-label" style="width: 100%;">æäº¤é€²åº¦:</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill" style="width: 0%;">0/0</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="section">
                <h3>4. ç‰¹æ®Šéšæ®µ</h3>
                <div class="info" style="margin-bottom: 8px;">ç¬¬ 6 å›åˆçµæŸå¾Œï¼ŒæŒ‰ä¸‹åˆ†é…æŒ‡ç¤ºç‰©ï¼›ç©å®¶å†å»ã€Œå–å¾—æŒ‡ç¤ºç‰©ã€ã€‚</div>
                <button onclick="assignIndicators()" id="btnAssignIndicators" disabled>åˆ†é…æŒ‡ç¤ºç‰©</button>
            </div>

            <div class="section">
                <h3>5. å¿«é€Ÿæ¸¬è©¦è¼”åŠ©</h3>
                <div class="info" style="margin-bottom: 8px;">
                    é€™äº›æŒ‰éˆ•ç”¨ä¾†çœå»æ‰‹å‹•è¼¸å…¥ï¼šæœƒè‡ªå‹•æŠŠæˆ¿è™Ÿå¡«å…¥ç©å®¶æ¬„ä½ï¼Œä¸¦ç”¨é è¨­æš±ç¨±åŠ å…¥ã€å–å›åˆã€å‡ºæ‹›ã€‚
                </div>
                <button onclick="fillRoomCode()" id="btnFillRoom" disabled>å¥—ç”¨æˆ¿è™Ÿåˆ°å…©ä½ç©å®¶</button>
                <button onclick="quickJoinPlayers()" id="btnQuickJoin" disabled>å…©ä½ç©å®¶ä¸€éµåŠ å…¥</button>
                <button onclick="quickSubmitChoices()" id="btnQuickSubmit" disabled>æœ¬è¼ªä¸€éµå‡ºæ‹›ï¼ˆP1 åŠ é€Ÿï¼ŒP2 è½‰å½ï¼‰</button>
            </div>

            <div class="section">
                <h3>6. æˆ¿é–“ç‹€æ…‹</h3>
                <div class="info" id="roomStatusInfo">
                    <div><span class="info-label">æˆ¿é–“ç‹€æ…‹:</span><span class="info-value" id="roomStatus">-</span></div>
                    <div><span class="info-label">ç›®å‰å›åˆ:</span><span class="info-value" id="currentRound">-</span></div>
                    <div><span class="info-label">ç©å®¶äººæ•¸:</span><span class="info-value" id="playerCount">-</span></div>
                </div>
            </div>

            <div class="section">
                <h3>7. ç¸½çµï¼ˆçµæŸå¾Œï¼‰</h3>
                <button onclick="getGameSummary()">å–å¾—ç¸½çµ</button>
                <div id="gameSummary"></div>
            </div>

            <div class="section">
                <h3>8. è¼ªè©¢ / äº‹ä»¶ç´€éŒ„</h3>
                <div class="info" style="margin-bottom: 8px;">æ¯ç§’è¼ªè©¢ /state æœƒæ–°å¢ä¸€ç­† logï¼ˆæœ‰ç„¡æ›´æ–°éƒ½æœƒé¡¯ç¤ºï¼‰ã€‚</div>
                <div class="log" id="wsLog"></div>
            </div>
        </div>

        <!-- PLAYER 1 PANEL -->
        <div class="panel">
            <h2>ğŸ‘¤ ç©å®¶ 1</h2>

            <div class="section">
                <h3>1. åŠ å…¥æˆ¿é–“</h3>
                <input type="text" id="p1Nickname" placeholder="è¼¸å…¥æš±ç¨±" value="Alice">
                <input type="text" id="p1RoomCode" placeholder="è¼¸å…¥æˆ¿è™Ÿ Code">
                <button onclick="joinRoom(1)">åŠ å…¥</button>
                <div class="info" id="p1Info" style="display: none;">
                    <div><span class="info-label">ç©å®¶ ID:</span><span class="info-value" id="p1PlayerId">-</span></div>
                    <div><span class="info-label">é¡¯ç¤ºåç¨±:</span><span class="info-value" id="p1DisplayName">-</span></div>
                </div>
            </div>

            <div class="section">
                <h3>2. ç•¶å‰å›åˆç‹€æ…‹</h3>
                <div class="info" style="margin-bottom: 8px;">å…ˆæŒ‰æ­¤å–å¾— round/phase/statusï¼Œå†å»ã€Œå–å¾—å°æ‰‹ã€ã€ã€Œå‡ºæ‹›ã€ã€‚</div>
                <button onclick="getRoundInfo(1)">å–å¾—å›åˆè³‡è¨Š</button>
                <div class="info" id="p1RoundInfo" style="display: none;">
                    <div><span class="info-label">å›åˆæ•¸:</span><span class="info-value" id="p1RoundNumber">-</span></div>
                    <div><span class="info-label">éšæ®µ:</span><span class="info-value" id="p1Phase">-</span></div>
                    <div><span class="info-label">ç‹€æ…‹:</span><span class="info-value" id="p1RoundStatus">-</span></div>
                </div>
                <div class="waiting-indicator" id="p1Waiting" style="display: none;">
                    â³ ç­‰ä¸»æŒäººå…¬å¸ƒçµæœä¸­...
                </div>
            </div>

            <div class="section">
                <h3>3. å–å¾—æœ¬è¼ªå°æ‰‹</h3>
                <button onclick="getPair(1)">å–å¾—å°æ‰‹</button>
                <div class="info" id="p1PairInfo" style="display: none;">
                    <div><span class="info-label">å°æ‰‹:</span><span class="info-value" id="p1OpponentName">-</span></div>
                </div>
            </div>

            <div class="section">
                <h3>4. å‡ºæ‹›</h3>
                <div class="info" style="margin-bottom: 8px;">æŒ‰å‰å…ˆç¢ºå®šå·²å–å¾—å›åˆèˆ‡å°æ‰‹è³‡è¨Šã€‚</div>
                <button class="choice-btn" onclick="submitAction(1, 'ACCELERATE')">âš¡ åŠ é€Ÿï¼ˆACCELERATEï¼‰</button>
                <button class="choice-btn" onclick="submitAction(1, 'TURN')">ğŸ”„ è½‰å½ï¼ˆTURNï¼‰</button>
            </div>

            <div class="section">
                <h3>5. çœ‹çµæœ</h3>
                <button onclick="getResult(1)">å–å¾—æœ¬è¼ªçµæœ</button>
                <div id="p1Results"></div>
            </div>

            <div class="section">
                <h3>6. ç•™è¨€ï¼ˆç¬¬ 5-6 å›åˆï¼‰</h3>
                <textarea id="p1Message" placeholder="çµ¦å°æ‰‹çš„çŸ­è¨Š..." rows="3"></textarea>
                <button onclick="sendMessage(1)">é€å‡ºç•™è¨€</button>
                <button onclick="getMessage(1)">æŸ¥çœ‹å°æ‰‹ç•™è¨€</button>
                <div class="message-box" id="p1MessageReceived" style="display: none;">
                    <strong>ä¾†è‡ªå°æ‰‹ï¼š</strong>
                    <div id="p1MessageContent"></div>
                </div>
            </div>

            <div class="section">
                <h3>7. æŒ‡ç¤ºç‰©ï¼ˆç¬¬ 6 å›åˆå¾Œï¼‰</h3>
                <button onclick="getIndicator(1)">å–å¾—æŒ‡ç¤ºç‰©</button>
                <div class="info" id="p1IndicatorInfo" style="display: none;">
                    <span class="info-label">ç¬¦è™Ÿ:</span>
                    <span class="indicator-symbol" id="p1Indicator">-</span>
                </div>
            </div>
        </div>

        <!-- PLAYER 2 PANEL -->
        <div class="panel">
            <h2>ğŸ‘¤ ç©å®¶ 2</h2>

            <div class="section">
                <h3>1. åŠ å…¥æˆ¿é–“</h3>
                <input type="text" id="p2Nickname" placeholder="è¼¸å…¥æš±ç¨±" value="Bob">
                <input type="text" id="p2RoomCode" placeholder="è¼¸å…¥æˆ¿è™Ÿ Code">
                <button onclick="joinRoom(2)">åŠ å…¥</button>
                <div class="info" id="p2Info" style="display: none;">
                    <div><span class="info-label">ç©å®¶ ID:</span><span class="info-value" id="p2PlayerId">-</span></div>
                    <div><span class="info-label">é¡¯ç¤ºåç¨±:</span><span class="info-value" id="p2DisplayName">-</span></div>
                </div>
            </div>

            <div class="section">
                <h3>2. ç•¶å‰å›åˆç‹€æ…‹</h3>
                <div class="info" style="margin-bottom: 8px;">å…ˆå–å¾—å›åˆè³‡è¨Šï¼Œå†ä¾åºå–å¾—å°æ‰‹ â†’ å‡ºæ‹› â†’ çœ‹çµæœã€‚</div>
                <button onclick="getRoundInfo(2)">å–å¾—å›åˆè³‡è¨Š</button>
                <div class="info" id="p2RoundInfo" style="display: none;">
                    <div><span class="info-label">å›åˆæ•¸:</span><span class="info-value" id="p2RoundNumber">-</span></div>
                    <div><span class="info-label">éšæ®µ:</span><span class="info-value" id="p2Phase">-</span></div>
                    <div><span class="info-label">ç‹€æ…‹:</span><span class="info-value" id="p2RoundStatus">-</span></div>
                </div>
                <div class="waiting-indicator" id="p2Waiting" style="display: none;">
                    â³ ç­‰ä¸»æŒäººå…¬å¸ƒçµæœä¸­...
                </div>
            </div>

            <div class="section">
                <h3>3. å–å¾—æœ¬è¼ªå°æ‰‹</h3>
                <button onclick="getPair(2)">å–å¾—å°æ‰‹</button>
                <div class="info" id="p2PairInfo" style="display: none;">
                    <div><span class="info-label">å°æ‰‹:</span><span class="info-value" id="p2OpponentName">-</span></div>
                </div>
            </div>

            <div class="section">
                <h3>4. å‡ºæ‹›</h3>
                <div class="info" style="margin-bottom: 8px;">ç¢ºèªå·²å–å¾—å›åˆèˆ‡å°æ‰‹è³‡è¨Šã€‚</div>
                <button class="choice-btn" onclick="submitAction(2, 'ACCELERATE')">âš¡ åŠ é€Ÿï¼ˆACCELERATEï¼‰</button>
                <button class="choice-btn" onclick="submitAction(2, 'TURN')">ğŸ”„ è½‰å½ï¼ˆTURNï¼‰</button>
            </div>

            <div class="section">
                <h3>5. çœ‹çµæœ</h3>
                <button onclick="getResult(2)">å–å¾—æœ¬è¼ªçµæœ</button>
                <div id="p2Results"></div>
            </div>

            <div class="section">
                <h3>6. ç•™è¨€ï¼ˆç¬¬ 5-6 å›åˆï¼‰</h3>
                <textarea id="p2Message" placeholder="çµ¦å°æ‰‹çš„çŸ­è¨Š..." rows="3"></textarea>
                <button onclick="sendMessage(2)">é€å‡ºç•™è¨€</button>
                <button onclick="getMessage(2)">æŸ¥çœ‹å°æ‰‹ç•™è¨€</button>
                <div class="message-box" id="p2MessageReceived" style="display: none;">
                    <strong>ä¾†è‡ªå°æ‰‹ï¼š</strong>
                    <div id="p2MessageContent"></div>
                </div>
            </div>

            <div class="section">
                <h3>7. æŒ‡ç¤ºç‰©ï¼ˆç¬¬ 6 å›åˆå¾Œï¼‰</h3>
                <button onclick="getIndicator(2)">å–å¾—æŒ‡ç¤ºç‰©</button>
                <div class="info" id="p2IndicatorInfo" style="display: none;">
                    <span class="info-label">ç¬¦è™Ÿ:</span>
                    <span class="indicator-symbol" id="p2Indicator">-</span>
                </div>
            </div>
        </div>

        <!-- QUICK FLOW PANEL -->
        <div class="panel">
            <h2>âš¡ å¿«é€Ÿæ¸¬è©¦æ­¥é©Ÿ</h2>
            <div class="section">
                <h3>ä¸€éµä¸‹ä¸€æ­¥</h3>
                <div class="info" style="margin-bottom: 8px;">
                    ä¾åºå®Œæˆï¼šé–‹æˆ¿ â†’ åŠ å…¥ â†’ Round1 æ±ºç­– â†’ Round2 æ±ºç­– â†’ è·³åˆ° Round5 ç•™è¨€ â†’ Round6 åˆ†é…æŒ‡ç¤ºç‰©ã€‚
                </div>
                <div class="info" style="margin-bottom: 8px;">
                    <strong>ç›®å‰æ­¥é©Ÿï¼š</strong> <span id="flowCurrent">-</span>
                </div>
                <button onclick="runNextFlowStep()" id="btnFlowNext">ä¸‹ä¸€æ­¥</button>
                <button onclick="resetFlow()">é‡ç½®æµç¨‹</button>
            </div>
            <div class="section">
                <h3>æ­¥é©Ÿæ¸…å–®ï¼ˆå¯å–®ç¨åŸ·è¡Œï¼‰</h3>
                <div class="flow-box" id="flowList"></div>
            </div>
        </div>
    </div>

    
    <script>
        // ============================================
        // Configuration
        // ============================================
        const API_BASE = 'http://localhost:8000/api';
        const POLL_INTERVAL_MS = 1000;

        // å¿«é€Ÿæµç¨‹å®šç¾©ï¼ˆç´°æ‹†ï¼‰
        const flowSequence = [
            { key: 'createRoom', label: 'é–‹æˆ¿é–“', action: async () => await createRoom() },
            { key: 'joinPlayers', label: 'ç©å®¶åŠ å…¥ï¼ˆP1/P2ï¼‰', action: async () => await quickJoinPlayers() },
            { key: 'startGame', label: 'é–‹å§‹éŠæˆ²ï¼ˆé€²å…¥ Round 1ï¼‰', action: async () => await startGame() },
            { key: 'round1Info', label: 'Round 1ï¼šå–å¾—å›åˆèˆ‡å°æ‰‹', action: async () => { await fetchLatestState(true); await getRoundInfo(1); await getPair(1); await getRoundInfo(2); await getPair(2); } },
            { key: 'round1Actions', label: 'Round 1ï¼šP1 åŠ é€Ÿ / P2 è½‰å½', action: async () => { await submitAction(1, 'ACCELERATE'); await submitAction(2, 'TURN'); } },
            { key: 'round1Publish', label: 'Round 1ï¼šå…¬å¸ƒçµæœ', action: async () => await publishRoundResults() },
            { key: 'toRound2', label: 'å‰å¾€ Round 2', action: async () => await nextRound() },
            { key: 'round2Info', label: 'Round 2ï¼šæ›´æ–°å›åˆè³‡è¨Šï¼ˆå°æ‰‹å›ºå®šï¼‰', action: async () => { await fetchLatestState(true); await getRoundInfo(1); await getRoundInfo(2); } },
            { key: 'round2Actions', label: 'Round 2ï¼šP1 è½‰å½ / P2 åŠ é€Ÿ', action: async () => { await submitAction(1, 'TURN'); await submitAction(2, 'ACCELERATE'); } },
            { key: 'round2Publish', label: 'Round 2ï¼šå…¬å¸ƒçµæœ', action: async () => await publishRoundResults() },
            { key: 'pushToRound5', label: 'æ¨é€²åˆ° Round 5ï¼ˆè·³éä¸­é–“ï¼‰', action: async () => { while ((state.host.currentRoundNumber || 0) < 5) { await nextRound(); await delay(200); } } },
            { key: 'round5Info', label: 'Round 5ï¼šæ›´æ–°å›åˆè³‡è¨Šï¼ˆå°æ‰‹å›ºå®šï¼‰', action: async () => { await fetchLatestState(true); await getRoundInfo(1); await getRoundInfo(2); } },
            { key: 'round5Actions', label: 'Round 5ï¼šP1 åŠ é€Ÿ / P2 è½‰å½', action: async () => { await submitAction(1, 'ACCELERATE'); await submitAction(2, 'TURN'); } },
            { key: 'round5Message', label: 'Round 5ï¼šäº’ç›¸ç•™è¨€', action: async () => { setDefaultMessage(1, 'Hi! ä¸‹ä¸€è¼ªåˆä½œå—ï¼Ÿ'); setDefaultMessage(2, 'å¥½å•Šï¼Œæˆ‘å€‘åˆä½œï¼'); await sendMessage(1); await sendMessage(2); await getMessage(1); await getMessage(2); } },
            { key: 'round5Publish', label: 'Round 5ï¼šå…¬å¸ƒçµæœ', action: async () => await publishRoundResults() },
            { key: 'toRound6', label: 'å‰å¾€ Round 6', action: async () => await nextRound() },
            { key: 'round6Info', label: 'Round 6ï¼šæ›´æ–°å›åˆè³‡è¨Šï¼ˆå°æ‰‹å›ºå®šï¼‰', action: async () => { await fetchLatestState(true); await getRoundInfo(1); await getRoundInfo(2); } },
            { key: 'round6Actions', label: 'Round 6ï¼šP1 è½‰å½ / P2 åŠ é€Ÿ', action: async () => { await submitAction(1, 'TURN'); await submitAction(2, 'ACCELERATE'); } },
            { key: 'round6Publish', label: 'Round 6ï¼šå…¬å¸ƒçµæœä¸¦åˆ†é…æŒ‡ç¤ºç‰©', action: async () => { await publishRoundResults(); await assignIndicators(); if (state.player1.playerId) await getIndicator(1); if (state.player2.playerId) await getIndicator(2); } }
        ];

        // ============================================
        // Global State
        // ============================================
        const initialFlowStatus = flowSequence.reduce((acc, step) => {
            acc[step.key] = 'pending';
            return acc;
        }, {});

        let pollTimer = null;
        let state = {
            host: { roomId: null, code: null, playerId: null, currentRoundNumber: null },
            player1: { roomId: null, playerId: null, displayName: null, currentRound: null },
            player2: { roomId: null, playerId: null, displayName: null, currentRound: null },
            roundProgress: { submitted: 0, total: 0 },
            messageSent: { p1: {}, p2: {} },
            indicatorsAssigned: false,
            firstPairFetched: { p1: false, p2: false },
            flowStatus: { ...initialFlowStatus },
            flowIndex: 0,
            pollVersion: 0
        };

        function getPollPlayerId() {
            return state.player1.playerId || state.player2.playerId || null;
        }

        // ============================================
        // Logging helpers
        // ============================================
        function logEvent(message, type = 'ws-event') {
            const logEl = document.getElementById('wsLog');
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${timestamp}] ${message}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
        }

        function logAPI(message) {
            console.log(`[API] ${message}`);
        }

        function updatePollBadge(running) {
            const statusEl = document.getElementById('wsStatus');
            if (running) {
                statusEl.textContent = 'POLL: RUNNING';
                statusEl.className = 'ws-status ws-connected';
            } else {
                statusEl.textContent = 'POLL: STOPPED';
                statusEl.className = 'ws-status ws-disconnected';
            }
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // ============================================
        // Short polling
        // ============================================
        function startPolling() {
            if (!state.host.roomId) return;
            stopPolling();
            updatePollBadge(true);
            logEvent('å•Ÿå‹•çŸ­è¼ªè©¢ (/state)', 'success');
            pollTimer = setInterval(() => pollState(), POLL_INTERVAL_MS);
            // ç«‹å³è£œä¸€ç™¼å®Œæ•´ç‹€æ…‹
            pollState(true);
        }

        function stopPolling() {
            if (pollTimer) {
                clearInterval(pollTimer);
                pollTimer = null;
            }
            updatePollBadge(false);
        }

        let isPolling = false;  // é˜²æ­¢é‡è¤‡è¼ªè©¢

        async function pollState(forceFull = false) {
            if (!state.host.roomId) return;

            // é˜²æ­¢é‡ç–Šçš„è¼ªè©¢è«‹æ±‚
            if (isPolling && !forceFull) {
                return;
            }

            isPolling = true;
            try {
                const version = forceFull ? 0 : state.pollVersion;
                const playerId = getPollPlayerId();
                let url = `${API_BASE}/rooms/${state.host.roomId}/state?version=${version}`;
                if (playerId) url += `&player_id=${playerId}`;

                logEvent(`POLL v${version} (player=${playerId || 'none'})`, 'api-call');
                const res = await fetch(url);
                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail || res.statusText);
                }
                const body = await res.json();
                if (!body.has_update) {
                    state.pollVersion = body.version;
                    // logEvent(`POLL v${body.version}: no update`, 'ws-event');  // æ¸›å°‘æ—¥èªŒ
                    return;
                }
                applyStateSnapshot(body.data, body.version, playerId);
                logEvent(`POLL v${version} â†’ v${body.version}: å·²æ›´æ–°`, 'success');
            } catch (err) {
                logEvent(`POLL error: ${err.message}`, 'error');
            } finally {
                isPolling = false;
            }
        }

        function applyStateSnapshot(payload, newVersion, polledPlayerId) {
            state.pollVersion = newVersion;
            if (!payload) return;

            // Room summary
            if (payload.room) {
                const room = payload.room;
                document.getElementById('roomStatus').textContent = room.status;
                document.getElementById('currentRound').textContent = room.current_round;
                document.getElementById('playerCount').textContent = room.player_count;
                state.host.currentRoundNumber = room.current_round;

                document.getElementById('btnStartGame').disabled = room.status !== 'WAITING';
                document.getElementById('btnNextRound').disabled = room.status !== 'PLAYING';
                document.getElementById('btnEndGame').disabled = room.status === 'FINISHED';
                document.getElementById('btnAssignIndicators').disabled = room.current_round < 6;
            }

            // Player list
            if (Array.isArray(payload.players)) {
                payload.players.forEach(p => {
                    if (p.player_id === state.player1.playerId) {
                        state.player1.displayName = p.display_name;
                    }
                    if (p.player_id === state.player2.playerId) {
                        state.player2.displayName = p.display_name;
                    }
                });
            }

            // Round info
            if (payload.round) {
                const round = payload.round;
                state.host.currentRoundNumber = round.round_number;
                state.player1.currentRound = round.round_number;
                state.player2.currentRound = round.round_number;

                document.getElementById('roundControlInfo').style.display = 'block';
                document.getElementById('roundControlNumber').textContent = round.round_number;
                document.getElementById('roundControlStatus').textContent = round.status;

                state.roundProgress = {
                    submitted: round.submitted_actions || 0,
                    total: round.total_players || 0
                };
                updateProgressBar();

                const waitingVisible = round.status === 'ready_to_publish';
                document.getElementById('p1Waiting').style.display = waitingVisible ? 'block' : 'none';
                document.getElementById('p2Waiting').style.display = waitingVisible ? 'block' : 'none';

                document.getElementById('btnPublishRound').disabled = round.status !== 'ready_to_publish';
                document.getElementById('btnSkipRound').disabled = !['waiting_actions', 'ready_to_publish'].includes(round.status);

                if (round.status === 'completed') {
                    if (state.player1.playerId) getResult(1);
                    if (state.player2.playerId) getResult(2);
                }
            }

            // Message (personalized)
            if (payload.message && polledPlayerId) {
                if (polledPlayerId === state.player1.playerId) {
                    document.getElementById('p1MessageContent').textContent = payload.message.content;
                    document.getElementById('p1MessageReceived').style.display = 'block';
                }
                if (polledPlayerId === state.player2.playerId) {
                    document.getElementById('p2MessageContent').textContent = payload.message.content;
                    document.getElementById('p2MessageReceived').style.display = 'block';
                }
            }

            // Indicators
            if (payload.indicators_assigned) {
                state.indicatorsAssigned = true;
                if (payload.indicator_symbol && polledPlayerId) {
                    if (polledPlayerId === state.player1.playerId) {
                        document.getElementById('p1Indicator').textContent = payload.indicator_symbol;
                        document.getElementById('p1IndicatorInfo').style.display = 'block';
                    }
                    if (polledPlayerId === state.player2.playerId) {
                        document.getElementById('p2Indicator').textContent = payload.indicator_symbol;
                        document.getElementById('p2IndicatorInfo').style.display = 'block';
                    }
                }
            }
        }

        function updateProgressBar() {
            const { submitted, total } = state.roundProgress;
            const percentage = total > 0 ? (submitted / total * 100) : 0;
            const progressFill = document.getElementById('progressFill');
            if (progressFill) {
                progressFill.style.width = `${percentage}%`;
                progressFill.textContent = `${submitted}/${total}`;
            }
        }

        // å¿«é€Ÿæµç¨‹ç‹€æ…‹ UI
        function setFlowStatus(step, status) {
            state.flowStatus[step] = status;
            const badge = document.querySelector(`[data-step="${step}"]`);
            if (!badge) return;
            badge.className = `badge badge-${status}`;
            const textMap = { pending: 'å¾…åŸ·è¡Œ', running: 'åŸ·è¡Œä¸­', done: 'å®Œæˆ', error: 'å¤±æ•—' };
            badge.textContent = textMap[status] || status;
        }

        function resetFlow() {
            Object.keys(state.flowStatus).forEach(step => setFlowStatus(step, 'pending'));
            state.flowIndex = 0;
            updateFlowCurrent();
            logEvent('å¿«é€Ÿæµç¨‹ç‹€æ…‹å·²é‡ç½®');
        }

        function updateFlowCurrent() {
            const current = flowSequence[state.flowIndex];
            const el = document.getElementById('flowCurrent');
            if (!el) return;
            el.textContent = current ? `${state.flowIndex + 1}. ${current.label}` : 'å…¨éƒ¨å®Œæˆ';
        }

        // ============================================
        // Host Functions
        // ============================================
        async function createRoom() {
            try {
                logAPI('POST /rooms');
                const response = await fetch(`${API_BASE}/rooms`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({}) });
                const data = await response.json();

                state.host.roomId = data.room_id;
                state.host.code = data.code;
                state.host.playerId = data.host_player_id;

                document.getElementById('hostRoomId').textContent = data.room_id;
                document.getElementById('hostCode').textContent = data.code;
                document.getElementById('hostPlayerId').textContent = data.host_player_id;
                document.getElementById('hostInfo').style.display = 'block';

                document.getElementById('p1RoomCode').value = data.code;
                document.getElementById('p2RoomCode').value = data.code;

                document.getElementById('btnStartGame').disabled = false;
                // Round < 6 æ™‚ä¸å¯åˆ†é…æŒ‡ç¤ºç‰©ï¼Œç­‰å¾…è¼ªè©¢å¾Œç”±ç‹€æ…‹æ§åˆ¶
                document.getElementById('btnAssignIndicators').disabled = true;

                document.getElementById('btnFillRoom').disabled = false;
                document.getElementById('btnQuickJoin').disabled = false;
                document.getElementById('btnQuickSubmit').disabled = false;

                startPolling();
                logEvent(`æˆ¿é–“å»ºç«‹: ${data.code}`, 'success');
                setFlowStatus('createRoom', 'done');
                return data;
            } catch (error) {
                logEvent(`Failed to create room: ${error.message}`, 'error');
                setFlowStatus('createRoom', 'error');
                return null;
            }
        }

        async function startGame() {
            if (!state.host.roomId) return;
            try {
                logAPI('POST /rooms/{room_id}/start');
                const res = await fetch(`${API_BASE}/rooms/${state.host.roomId}/start`, { method: 'POST' });
                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail);
                }
                logEvent('Game start requested', 'success');
                setFlowStatus('startGame', 'done');
                await fetchLatestState(true);
                return true;
            } catch (error) {
                logEvent(`Failed to start game: ${error.message}`, 'error');
                setFlowStatus('startGame', 'error');
                return false;
            }
        }

        async function nextRound() {
            if (!state.host.roomId) return;
            try {
                logAPI('POST /rooms/{room_id}/rounds/next');
                const res = await fetch(`${API_BASE}/rooms/${state.host.roomId}/rounds/next`, { method: 'POST' });
                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail);
                }
                const data = await res.json();
                logEvent(`Next round request sent: Round ${data.round_number}`, 'success');
                setFlowStatus('nextRound', 'done');
                await fetchLatestState(true);
                return data;
            } catch (error) {
                logEvent(`Failed to start next round: ${error.message}`, 'error');
                setFlowStatus('nextRound', 'error');
                return null;
            }
        }

        async function publishRoundResults() {
            const roundNumber = state.host.currentRoundNumber;
            if (!state.host.roomId || !roundNumber) return;
            if (!confirm(`Publish results for Round ${roundNumber}?`)) return;
            try {
                // å…ˆç¢ºå®šç‹€æ…‹å·² ready_to_publish
                await fetchLatestState(true);
                const currentStatus = document.getElementById('roundControlStatus').textContent || '';
                if (currentStatus.toLowerCase() !== 'ready_to_publish') {
                    logEvent(`Round ${roundNumber} å°šæœª ready_to_publishï¼ˆç›®å‰ ${currentStatus || 'æœªçŸ¥'}ï¼‰`, 'error');
                    return false;
                }

                logAPI(`POST /rooms/{room_id}/rounds/${roundNumber}/publish`);
                const res = await fetch(`${API_BASE}/rooms/${state.host.roomId}/rounds/${roundNumber}/publish`, { method: 'POST' });
                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail);
                }
                logEvent(`Round ${roundNumber} results published`, 'success');
                await fetchLatestState(true);
                return true;
            } catch (error) {
                logEvent(`Failed to publish results: ${error.message}`, 'error');
                return false;
            }
        }

        async function skipRound() {
            const roundNumber = state.host.currentRoundNumber;
            if (!state.host.roomId || !roundNumber) return;
            if (!confirm(`Skip Round ${roundNumber}? æœªæäº¤çš„ç©å®¶æœƒè‡ªå‹• TURNã€‚`)) return;
            try {
                logAPI(`POST /rooms/{room_id}/rounds/${roundNumber}/skip`);
                const res = await fetch(`${API_BASE}/rooms/${state.host.roomId}/rounds/${roundNumber}/skip`, { method: 'POST' });
                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail);
                }
                logEvent(`Round ${roundNumber} skipped`, 'success');
                await fetchLatestState(true);
            } catch (error) {
                logEvent(`Failed to skip round: ${error.message}`, 'error');
            }
        }

        async function endGame() {
            if (!state.host.roomId) return;
            try {
                logAPI('POST /rooms/{room_id}/end');
                const res = await fetch(`${API_BASE}/rooms/${state.host.roomId}/end`, { method: 'POST' });
                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail);
                }
                logEvent('Game end request sent', 'success');
                await fetchLatestState(true);
            } catch (error) {
                logEvent(`Failed to end game: ${error.message}`, 'error');
            }
        }

        async function updateRoomStatus() {
            if (!state.host.code) return;
            try {
                const response = await fetch(`${API_BASE}/rooms/${state.host.code}`);
                const data = await response.json();
                document.getElementById('roomStatus').textContent = data.status.toUpperCase();
                document.getElementById('currentRound').textContent = data.current_round;
                document.getElementById('playerCount').textContent = data.player_count;
            } catch (error) {
                console.error('Failed to update room status:', error);
            }
        }

        async function assignIndicators() {
            if (!state.host.roomId) return;
            if ((state.host.currentRoundNumber || 0) < 6) {
                logEvent('æŒ‡ç¤ºç‰©åªèƒ½åœ¨ç¬¬ 6 å›åˆå¾Œåˆ†é…ï¼Œè«‹å…ˆæ¨é€²åˆ° Round 6 ä¸¦å…¬å¸ƒçµæœ', 'error');
                return;
            }
            try {
                logAPI('POST /rooms/{room_id}/indicators/assign');
                const response = await fetch(`${API_BASE}/rooms/${state.host.roomId}/indicators/assign`, { method: 'POST' });
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail);
                }
                logEvent('Indicators assigned', 'success');
                await fetchLatestState(true);
            } catch (error) {
                logEvent(`Failed to assign indicators: ${error.message}`, 'error');
            }
        }

        // ============================================
        // Player Functions
        // ============================================
        async function joinRoom(playerNum) {
            const nickname = document.getElementById(`p${playerNum}Nickname`).value;
            const roomCode = document.getElementById(`p${playerNum}RoomCode`).value;
            if (!nickname || !roomCode) { alert('Please enter nickname and room code'); return; }
            try {
                logAPI(`POST /rooms/${roomCode}/join`);
                const res = await fetch(`${API_BASE}/rooms/${roomCode}/join`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ nickname }) });
                if (!res.ok) { const err = await res.json(); throw new Error(err.detail); }
                const data = await res.json();
                state[`player${playerNum}`].roomId = data.room_id;
                state[`player${playerNum}`].playerId = data.player_id;
                state[`player${playerNum}`].displayName = data.display_name;
                document.getElementById(`p${playerNum}PlayerId`).textContent = data.player_id;
                document.getElementById(`p${playerNum}DisplayName`).textContent = data.display_name;
                document.getElementById(`p${playerNum}Info`).style.display = 'block';
                logEvent(`Player ${playerNum} joined: ${data.display_name}`, 'success');
                await fetchLatestState(true);
                return true;
            } catch (error) {
                logEvent(`Player ${playerNum} failed to join: ${error.message}`, 'error');
                return false;
            }
        }

        async function getRoundInfo(playerNum) {
            const roomId = state[`player${playerNum}`].roomId;
            if (!roomId) return;
            try {
                logAPI('GET /rooms/{room_id}/rounds/current');
                const res = await fetch(`${API_BASE}/rooms/${roomId}/rounds/current`);
                if (!res.ok) { const err = await res.json(); throw new Error(err.detail); }
                const data = await res.json();
                state[`player${playerNum}`].currentRound = data.round_number;
                document.getElementById(`p${playerNum}RoundNumber`).textContent = data.round_number;
                document.getElementById(`p${playerNum}Phase`).textContent = data.phase;
                document.getElementById(`p${playerNum}RoundStatus`).textContent = data.status;
                document.getElementById(`p${playerNum}RoundInfo`).style.display = 'block';
                const waitingEl = document.getElementById(`p${playerNum}Waiting`);
                waitingEl.style.display = data.status === 'ready_to_publish' ? 'block' : 'none';
                if (data.status === 'completed') await getResult(playerNum);
                logEvent(`Player ${playerNum} round info updated`, 'success');
            } catch (error) {
                logEvent(`Player ${playerNum} failed to get round info: ${error.message}`, 'error');
            }
        }

        function fillRoomCode() {
            if (!state.host.code) { alert('è«‹å…ˆå»ºç«‹æˆ¿é–“'); return; }
            document.getElementById('p1RoomCode').value = state.host.code;
            document.getElementById('p2RoomCode').value = state.host.code;
            logEvent(`å·²å¥—ç”¨æˆ¿è™Ÿ ${state.host.code} åˆ°å…©ä½ç©å®¶`, 'success');
        }

        async function quickJoinPlayers() {
            if (!state.host.code) { alert('è«‹å…ˆå»ºç«‹æˆ¿é–“'); return; }
            document.getElementById('p1RoomCode').value = state.host.code;
            document.getElementById('p2RoomCode').value = state.host.code;
            const r1 = await joinRoom(1);
            const r2 = await joinRoom(2);
            if (r1 && r2) {
                setFlowStatus('joinPlayers', 'done');
                return true;
            } else {
                setFlowStatus('joinPlayers', 'error');
                throw new Error('ç©å®¶åŠ å…¥å¤±æ•—');
            }
        }

        async function quickSubmitChoices() {
            await getRoundInfo(1); await getRoundInfo(2);
            await submitAction(1, 'ACCELERATE');
            await submitAction(2, 'TURN');
        }

        // Flow runner
        async function runFlowStep(step) {
            try {
                setFlowStatus(step, 'running');
                let result = true;
                switch (step) {
                    case 'createRoom': result = await createRoom(); break;
                    case 'joinPlayers': result = await quickJoinPlayers(); break;
                    case 'startGame': result = await startGame(); break;
                    case 'round1Info': await getRoundInfo(1); await getPair(1); await getRoundInfo(2); await getPair(2); break;
                    case 'round2Info': case 'round5Info': case 'round6Info': await getRoundInfo(1); await getRoundInfo(2); break;
                    case 'round1Actions': await submitAction(1, 'ACCELERATE'); await submitAction(2, 'TURN'); break;
                    case 'round2Actions': await submitAction(1, 'TURN'); await submitAction(2, 'ACCELERATE'); break;
                    case 'round5Actions': await submitAction(1, 'ACCELERATE'); await submitAction(2, 'TURN'); break;
                    case 'round5Message': setDefaultMessage(1, 'Hi! ä¸‹ä¸€è¼ªåˆä½œå—ï¼Ÿ'); setDefaultMessage(2, 'å¥½å•Šï¼Œæˆ‘å€‘åˆä½œï¼'); await sendMessage(1); await sendMessage(2); await getMessage(1); await getMessage(2); break;
                    case 'round1Publish': case 'round2Publish': case 'round5Publish': result = await publishRoundResults(); break;
                    case 'toRound2': case 'toRound6': result = await nextRound(); break;
                    case 'pushToRound5': while ((state.host.currentRoundNumber || 0) < 5) { await nextRound(); await delay(200); } break;
                    case 'round6Actions': await submitAction(1, 'TURN'); await submitAction(2, 'ACCELERATE'); break;
                    case 'round6Publish': await publishRoundResults(); await assignIndicators(); if (state.player1.playerId) await getIndicator(1); if (state.player2.playerId) await getIndicator(2); break;
                }
                if (result === false || result === null) throw new Error('step failed');
                setFlowStatus(step, 'done');
                const nextIndex = flowSequence.findIndex(s => s.key === step) + 1;
                state.flowIndex = nextIndex;
                updateFlowCurrent();
            } catch (e) {
                console.error(e);
                setFlowStatus(step, 'error');
            }
        }

        async function runNextFlowStep() {
            if (state.flowIndex >= flowSequence.length) { logEvent('æ‰€æœ‰æµç¨‹å·²å®Œæˆ'); return; }
            const step = flowSequence[state.flowIndex];
            await runFlowStep(step.key);
        }

        async function getPair(playerNum) {
            const roomId = state[`player${playerNum}`].roomId;
            const playerId = state[`player${playerNum}`].playerId;
            const roundNumber = state[`player${playerNum}`].currentRound;
            if (!roomId || !playerId || !roundNumber) { alert('Please get round info first'); return; }
            try {
                logAPI(`GET /rooms/{room_id}/rounds/${roundNumber}/pair`);
                const response = await fetch(`${API_BASE}/rooms/${roomId}/rounds/${roundNumber}/pair?player_id=${playerId}`);
                if (!response.ok) { const error = await response.json(); throw new Error(error.detail); }
                const data = await response.json();
                document.getElementById(`p${playerNum}OpponentName`).textContent = data.opponent_display_name;
                document.getElementById(`p${playerNum}PairInfo`).style.display = 'block';
                state.firstPairFetched[playerNum === 1 ? 'p1' : 'p2'] = true;
                logEvent(`Player ${playerNum} opponent: ${data.opponent_display_name}`, 'success');
            } catch (error) {
                logEvent(`Player ${playerNum} failed to get pair: ${error.message}`, 'error');
            }
        }

        async function submitAction(playerNum, choice) {
            const roomId = state[`player${playerNum}`].roomId;
            const playerId = state[`player${playerNum}`].playerId;
            const roundNumber = state[`player${playerNum}`].currentRound;
            const choiceValue = choice.toUpperCase();
            if (!roomId || !playerId || !roundNumber) { alert('Please get round info first'); return; }
            try {
                logAPI(`POST /rooms/{room_id}/rounds/${roundNumber}/action`);
                const res = await fetch(`${API_BASE}/rooms/${roomId}/rounds/${roundNumber}/action`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ player_id: playerId, choice: choiceValue }) });
                if (!res.ok) { const err = await res.json(); throw new Error(err.detail); }
                logEvent(`Player ${playerNum} chose: ${choiceValue}`, 'success');
                await fetchLatestState(true);
            } catch (error) {
                logEvent(`Player ${playerNum} failed to submit action: ${error.message}`, 'error');
            }
        }

        async function getResult(playerNum) {
            const roomId = state[`player${playerNum}`].roomId;
            const playerId = state[`player${playerNum}`].playerId;
            const roundNumber = state[`player${playerNum}`].currentRound;
            if (!roomId || !playerId || !roundNumber) { alert('Please get round info first'); return; }
            try {
                logAPI(`GET /rooms/{room_id}/rounds/${roundNumber}/result`);
                const response = await fetch(`${API_BASE}/rooms/${roomId}/rounds/${roundNumber}/result?player_id=${playerId}`);
                if (!response.ok) { const error = await response.json(); throw new Error(error.detail); }
                const data = await response.json();
                const resultBox = document.createElement('div');
                resultBox.className = 'result-box';
                resultBox.innerHTML = `
                    <h4>Round ${roundNumber} Result</h4>
                    <div><strong>Opponent:</strong> ${data.opponent_display_name}</div>
                    <div><strong>Your Choice:</strong> ${data.your_choice}</div>
                    <div><strong>Opponent Choice:</strong> ${data.opponent_choice}</div>
                    <div class="${data.your_payoff >= 0 ? 'payoff-positive' : 'payoff-negative'}">
                        <strong>Your Payoff:</strong> ${data.your_payoff}
                    </div>
                `;
                const resultsContainer = document.getElementById(`p${playerNum}Results`);
                resultsContainer.insertBefore(resultBox, resultsContainer.firstChild);
                logEvent(`Player ${playerNum} got result for round ${roundNumber}`, 'success');
            } catch (error) {
                logEvent(`Player ${playerNum} failed to get result: ${error.message}`, 'error');
            }
        }

        async function sendMessage(playerNum) {
            const roomId = state[`player${playerNum}`].roomId;
            const playerId = state[`player${playerNum}`].playerId;
            const roundNumber = state[`player${playerNum}`].currentRound;
            const content = document.getElementById(`p${playerNum}Message`).value;
            if (!roomId || !playerId || !roundNumber) { alert('Please get round info first'); return; }
            if (!content) { alert('Please enter a message'); return; }
            try {
                logAPI(`POST /rooms/{room_id}/rounds/${roundNumber}/message`);
                const response = await fetch(`${API_BASE}/rooms/${roomId}/rounds/${roundNumber}/message`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ sender_id: playerId, content }) });
                if (!response.ok) { const error = await response.json(); throw new Error(error.detail); }
                document.getElementById(`p${playerNum}Message`).value = '';
                logEvent(`Player ${playerNum} sent message`, 'success');
                await fetchLatestState(true);
            } catch (error) {
                logEvent(`Player ${playerNum} failed to send message: ${error.message}`, 'error');
            }
        }

        function setDefaultMessage(playerNum, text) {
            const box = document.getElementById(`p${playerNum}Message`);
            if (box && !box.value) box.value = text;
        }

        async function getMessage(playerNum) {
            const roomId = state[`player${playerNum}`].roomId;
            const playerId = state[`player${playerNum}`].playerId;
            const roundNumber = state[`player${playerNum}`].currentRound;
            if (!roomId || !playerId || !roundNumber) { alert('Please get round info first'); return; }
            try {
                logAPI(`GET /rooms/{room_id}/rounds/${roundNumber}/message`);
                const response = await fetch(`${API_BASE}/rooms/${roomId}/rounds/${roundNumber}/message?player_id=${playerId}`);
                if (!response.ok) { const error = await response.json(); throw new Error(error.detail); }
                const data = await response.json();
                document.getElementById(`p${playerNum}MessageContent`).textContent = data.content;
                document.getElementById(`p${playerNum}MessageReceived`).style.display = 'block';
                logEvent(`Player ${playerNum} received message`, 'success');
            } catch (error) {
                logEvent(`Player ${playerNum} failed to get message: ${error.message}`, 'error');
            }
        }

        async function getIndicator(playerNum) {
            const roomId = state[`player${playerNum}`].roomId;
            const playerId = state[`player${playerNum}`].playerId;
            if (!roomId || !playerId) { alert('Please join room first'); return; }
            try {
                logAPI(`GET /rooms/{room_id}/indicator`);
                const response = await fetch(`${API_BASE}/rooms/${roomId}/indicator?player_id=${playerId}`);
                if (!response.ok) { const error = await response.json(); throw new Error(error.detail); }
                const data = await response.json();
                document.getElementById(`p${playerNum}Indicator`).textContent = data.symbol;
                document.getElementById(`p${playerNum}IndicatorInfo`).style.display = 'block';
                logEvent(`Player ${playerNum} indicator: ${data.symbol}`, 'success');
            } catch (error) {
                logEvent(`Player ${playerNum} failed to get indicator: ${error.message}`, 'error');
            }
        }

        async function getGameSummary() {
            if (!state.host.roomId) return;
            try {
                logAPI('GET /rooms/{room_id}/summary');
                const response = await fetch(`${API_BASE}/rooms/${state.host.roomId}/summary`);
                if (!response.ok) { const error = await response.json(); throw new Error(error.detail); }
                const data = await response.json();
                let html = '<div class="result-box"><h4>ğŸ† Game Summary</h4>';
                html += '<h5 style="color: #00ffff; margin: 15px 0 10px 0;">Rankings</h5>';
                data.players.forEach((player, index) => {
                    const rankEmoji = index === 0 ? 'ğŸ¥‡' : index === 1 ? 'ğŸ¥ˆ' : 'ğŸ¥‰';
                    const payoffClass = player.total_payoff >= 0 ? 'payoff-positive' : 'payoff-negative';
                    html += `<div style="margin: 5px 0;">${rankEmoji} <strong>${player.display_name}</strong>: <span class="${payoffClass}">${player.total_payoff}</span></div>`;
                });
                html += '<h5 style="color: #00ffff; margin: 15px 0 10px 0;">Strategy Statistics</h5>';
                html += `<div style="margin: 5px 0;">âš¡ Accelerate: <span class="info-value">${(data.stats.accelerate_ratio * 100).toFixed(1)}%</span></div>`;
                html += `<div style="margin: 5px 0;">ğŸ”„ Turn: <span class="info-value">${(data.stats.turn_ratio * 100).toFixed(1)}%</span></div>`;
                html += '</div>';
                document.getElementById('gameSummary').innerHTML = html;
                logEvent('Game summary loaded', 'success');
            } catch (error) {
                logEvent(`Failed to get game summary: ${error.message}`, 'error');
            }
        }

        // Helpers
        async function fetchLatestState(forceFull = false) {
            await pollState(forceFull);
        }

        // ============================================
        // Initialize
        // ============================================
        function renderFlowList() {
            const container = document.getElementById('flowList');
            if (!container) return;
            container.innerHTML = '';
            flowSequence.forEach((step, idx) => {
                const row = document.createElement('div');
                row.className = 'flow-row';
                row.innerHTML = `
                    <div class="flow-step">${idx + 1}</div>
                    <div>${step.label}</div>
                    <span class="badge badge-pending" data-step="${step.key}">å¾…åŸ·è¡Œ</span>
                    <button onclick="runFlowStep('${step.key}')">åŸ·è¡Œ</button>
                `;
                container.appendChild(row);
            });
        }

        renderFlowList();
        updateFlowCurrent();
        logEvent('æ¸¬è©¦æ§å° v2.1 åˆå§‹åŒ–ï¼ˆçŸ­è¼ªè©¢ç‰ˆï¼‰');
        logEvent('è«‹å…ˆé»ã€Œå»ºç«‹æˆ¿é–“ã€é–‹å§‹æµç¨‹æˆ–ç”¨å¿«é€Ÿæ­¥é©Ÿçš„ã€Œä¸‹ä¸€æ­¥ã€');
    </script>

</body>
</html>
